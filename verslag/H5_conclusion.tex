
In short, all components are in place in the framework to generate easily and efficiently all the blocks. Since day one, this is a constant work in progress

\subsection{Size limitation}
The main bottleneck is, as expected, calculating the matrix exponential for large systems. The other components are efficient enough to not cause any troubles.

\subsection{Lattices}
The models studied were all on a square lattice. The universal physics does not depend on the details of the model, such as the lattice. It would be beneficial to be able to simulate to these lattices, but here also higher dimensions could be included. In essence all the information of the lattice is contained in the maps generated for each calculation, such as all the connected sites, how to contract them, etcetera. Although undoubtedly many details will need to be changed to use it in practice, the solvers can stay almost the same.

\subsection{Symmetries}

At the moment rotation and permutation symmetries can be included in the construction of the blocks. Internal symmetries are not yet included at the moment. Including them could push the computational boundaries further.

\subsection{Code quality}
The first and most important goal of writing numerical code is of course that it compiles and that the results are as correct. But this is only the first step. The 2D framework neatly orders the different task is functions to avoid as much code duplication as possible. For instance, there are functions generating and manipulating maps, which depends on the geometry of the problem. Other functions only use the bonds and contractions listed in that map object, and hence another lattice can be used without changing the other components too much.

Another example is the solvers, which get the blocks through a common function

\todo{finish this}